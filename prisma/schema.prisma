// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["typedSql"]
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id       String  @id @default(cuid())
  email    String  @unique
  username String  @unique
  name     String?
  active   Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 2FA fields
  twoFactorSecret  String?
  twoFactorEnabled Boolean @default(false)

  // Existing relationships
  image       UserImage?
  password    Password?
  notes       Note[]
  roles       Role[]
  sessions    Session[]
  connections Connection[]
  passkey     Passkey[]

  // Interex specific relationships
  customer        Customer?      @relation(fields: [customerId], references: [id])
  customerId      String?
  providerGroup   ProviderGroup? @relation(fields: [providerGroupId], references: [id])
  providerGroupId String?

  // User can be assigned multiple NPIs
  userNpis UserNpi[]

  // Submissions created by this user
  submissions         Submission[]
  submissionDocuments SubmissionDocument[]

  providerEventsAuthored ProviderEvent[] @relation("ProviderEventActor")

  @@index([customerId])
  @@index([providerGroupId])
}

model Note {
  id      String @id @default(cuid())
  title   String
  content String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String

  images NoteImage[]

  @@index([ownerId])
  @@index([ownerId, updatedAt])
}

model NoteImage {
  id        String  @id @default(cuid())
  altText   String?
  objectKey String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  noteId String

  @@index([noteId])
}

model UserImage {
  id        String  @id @default(cuid())
  altText   String?
  objectKey String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Password {
  hash String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Session {
  id             String   @id @default(cuid())
  expirationDate DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  @@index([userId])
}

model Permission {
  id          String @id @default(cuid())
  action      String
  entity      String
  access      String
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  roles Role[]

  @@unique([action, entity, access])
}

model Role {
  id          String  @id @default(cuid())
  name        String  @unique
  description String  @default("")
  active      Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users       User[]
  permissions Permission[]
}

model Verification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  type      String
  target    String
  secret    String
  algorithm String
  digits    Int
  period    Int
  charSet   String
  expiresAt DateTime?

  @@unique([target, type])
}

model Connection {
  id           String @id @default(cuid())
  providerName String
  providerId   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  @@unique([providerName, providerId])
}

model Passkey {
  id             String   @id
  aaguid         String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  publicKey      Bytes
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  webauthnUserId String
  counter        BigInt
  deviceType     String
  backedUp       Boolean
  transports     String?

  @@index([userId])
}

// =============================================
// CMS Interex User Management Models
// =============================================

model Customer {
  id          String  @id @default(cuid())
  name        String
  description String  @default("")
  active      Boolean @default(true)

  baaNumber String?   @unique
  baaDate   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users              User[]
  providerGroups     ProviderGroup[]
  providers          Provider[]
  submissions        Submission[]
  providerEvents     ProviderEvent[]
  PrepayLetter       PrepayLetter[]
  PostpayLetter      PostpayLetter[]
  PostpayOtherLetter PostpayOtherLetter[]

  @@index([name])
}

model ProviderGroup {
  id          String  @id @default(cuid())
  name        String
  description String  @default("")
  active      Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId String

  users              User[]
  providers          Provider[]
  PrepayLetter       PrepayLetter[]
  PostpayLetter      PostpayLetter[]
  PostpayOtherLetter PostpayOtherLetter[]

  @@unique([customerId, name])
  @@index([customerId])
}

model Provider {
  id     String  @id @default(cuid())
  npi    String  @unique
  name   String?
  active Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer        Customer       @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId      String
  providerGroup   ProviderGroup? @relation(fields: [providerGroupId], references: [id])
  providerGroupId String?

  userNpis    UserNpi[]
  submissions Submission[]
  events      ProviderEvent[]

  // Persist eMDR/PCG details locally (legacy fields kept to avoid breaking existing code)
  providerStreet  String?
  providerStreet2 String?
  providerCity    String?
  providerState   String?
  providerZip     String?

  pcgProviderId     String?
  pcgUpdateResponse Json?
  pcgUpdateAt       DateTime?

  // Legacy snapshot of the /providers row + timestamp
  pcgListSnapshot Json?
  pcgListAt       DateTime?

  // NEW relations to persistent tables
  listDetail         ProviderListDetail?
  registrationStatus ProviderRegistrationStatus?
  PrepayLetter       PrepayLetter[]
  PostpayLetter      PostpayLetter[]
  PostpayOtherLetter PostpayOtherLetter[]

  @@index([customerId])
  @@index([providerGroupId])
  @@index([npi])
}

model UserNpi {
  id String @id @default(cuid())

  createdAt DateTime @default(now())

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  providerId String

  @@unique([userId, providerId])
  @@index([userId])
  @@index([providerId])
}

// =============================================
// NEW: Persistent tables for eMDR
// =============================================

/// Latest row from PCG `/providers` for each Provider (one row per provider)
model ProviderListDetail {
  id        String   @id @default(cuid())
  fetchedAt DateTime @default(now())

  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  providerId String   @unique

  // Keys / identities
  providerNpi   String
  pcgProviderId String?

  // Flags / status
  lastSubmittedTransaction        String?
  registeredForEmdr               Boolean @default(false)
  registeredForEmdrElectronicOnly Boolean @default(false)
  stage                           String?
  regStatus                       String?
  status                          String?
  esMDTransactionID               String?

  // Address / name
  providerName    String?
  providerStreet  String?
  providerStreet2 String?
  providerCity    String?
  providerState   String?
  providerZip     String?

  // Misc (as JSON blobs to retain full API payloads)
  transactionIdList   String?
  notificationDetails Json?
  statusChanges       Json?
  errors              Json?
  errorList           Json?
}

/// Latest row from `pcgGetProviderRegistration` for each Provider (one row per provider)
model ProviderRegistrationStatus {
  id        String   @id @default(cuid())
  fetchedAt DateTime @default(now())

  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  providerId String   @unique

  // Keys / identities
  providerNpi   String
  pcgProviderId String

  // Status
  regStatus        String?
  stage            String?
  submissionStatus String?
  status           String?

  // Error surfaces
  callErrorCode        String?
  callErrorDescription String?

  // Address / name
  providerName    String?
  providerStreet  String?
  providerStreet2 String?
  providerCity    String?
  providerState   String?
  providerZip     String?

  // Misc
  transactionIdList String?
  statusChanges     Json?
  errors            Json?
  errorList         Json?
}

// =============================================
// Submission Management Models (HIH-compatible)
// =============================================

model Submission {
  id                  String            @id @default(cuid())
  title               String
  purposeOfSubmission SubmissionPurpose
  recipient           String
  claimId             String?
  caseId              String?
  comments            String?
  status              SubmissionStatus  @default(DRAFT)
  authorType          String            @default("Individual")

  autoSplit Boolean            @default(false)
  category  SubmissionCategory @default(DEFAULT)
  sendInX12 Boolean            @default(false)
  threshold Int                @default(100)

  pcgSubmissionId    String?
  fhirAcknowledgment String?
  transactionId      String?
  responseMessage    String?
  errorDescription   String?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  submittedAt DateTime?

  creator    User     @relation(fields: [creatorId], references: [id])
  creatorId  String
  provider   Provider @relation(fields: [providerId], references: [id])
  providerId String
  customer   Customer @relation(fields: [customerId], references: [id])
  customerId String

  documents SubmissionDocument[]
  events    SubmissionEvent[]

  @@unique([pcgSubmissionId])
  @@index([creatorId])
  @@index([providerId])
  @@index([customerId])
  @@index([status])
  @@index([purposeOfSubmission])
}

model SubmissionDocument {
  id                      String               @id @default(cuid())
  title                   String?
  fileName                String
  originalFileName        String
  fileSize                Int
  mimeType                String
  objectKey               String
  language                String               @default("English")
  documentType            DocumentType         @default(PDF)
  attachmentControlNumber String?
  comments                String?
  fhirResourceId          String?
  uploadStatus            DocumentUploadStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  submissionId String
  uploader     User       @relation(fields: [uploaderId], references: [id])
  uploaderId   String

  @@index([submissionId])
  @@index([uploaderId])
}

enum DocumentUploadStatus {
  PENDING
  UPLOADING
  UPLOADED
  UPLOAD_FAILED
}

enum SubmissionCategory {
  DEFAULT
  MEDICAL_REVIEW
  NON_MEDICAL_REVIEW
  RESPONSES_FOR_PA
}

enum SubmissionPurpose {
  ADR
  PA_ABT
  PA_DMEPOS
  HH_PRE_CLAIM
  HOPD
  PWK_CLAIM_DOCUMENTATION
  FIRST_APPEAL
  SECOND_APPEAL
  DME_DISCUSSION
  RA_DISCUSSION
  ADMC
  IRF
  PROVIDER_MANAGEMENT
  POST_PAY_EMDR
  PRE_PAY_EMDR
  POST_PAY_OTHER_EMDR
  PADL_RRL_LETTERS
}

enum SubmissionStatus {
  DRAFT
  SUBMITTED
  PROCESSING
  COMPLETED
  REJECTED
  ERROR
}

enum DocumentType {
  PDF
  DOC
  DOCX
  TXT
  JPG
  JPEG
  PNG
  TIFF
  XLS
  XLSX
}

model ApiToken {
  id          String   @id @default(cuid())
  provider    String   @unique
  accessToken String
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([expiresAt])
}

enum SubmissionEventKind {
  DRAFT_CREATED
  PCG_CREATE_SUCCESS
  PCG_CREATE_ERROR
  PCG_UPLOAD_SUCCESS
  PCG_UPLOAD_ERROR
  PCG_STATUS
  PCG_UPDATE_SUCCESS
  PCG_UPDATE_ERROR
  META_UPDATED
}

model SubmissionEvent {
  id           String              @id @default(cuid())
  submission   Submission          @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  submissionId String
  kind         SubmissionEventKind
  message      String?
  payload      Json?
  createdAt    DateTime            @default(now())
}

enum ProviderEventKind {
  CREATED
  UPDATED
  ACTIVATED
  INACTIVATED
  GROUP_ASSIGNED
  GROUP_UNASSIGNED
  PCG_ADD_ATTEMPT
  PCG_ADD_ERROR
}

model ProviderEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  kind    ProviderEventKind
  message String?
  payload Json?

  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  providerId String

  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId String

  actor   User?   @relation("ProviderEventActor", fields: [actorId], references: [id])
  actorId String?

  @@index([providerId])
  @@index([customerId, createdAt])
}

// =============================================
// Letters (separate tables per type)
// =============================================

model PrepayLetter {
  id               String    @id @default(cuid())
  externalLetterId String    @unique // usually eMDRMetaData.uniqueLetterId or letterID
  downloadId       String? // eMDRPrePayID (used by download API if present)
  providerNpi      String
  providerId       String?
  provider         Provider? @relation(fields: [providerId], references: [id])

  // allow filtering by customer quickly
  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id])

  providerGroupId String?
  providerGroup   ProviderGroup? @relation(fields: [providerGroupId], references: [id])

  esmdTransactionId String?
  hihDeliveryAt     DateTime?
  letterDate        DateTime?
  respondBy         DateTime?
  jurisdiction      String?
  programName       String?
  stage             String?
  language          String?
  bSendAck          Boolean?
  ackUniqueId       String?
  rcOid             String?
  letterName        String?

  raw Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([customerId])
  @@index([providerNpi])
  @@index([letterDate])
}

model PostpayLetter {
  id               String    @id @default(cuid())
  externalLetterId String    @unique
  downloadId       String? // e.g., eMDRPostPayID if PCG sends it
  providerNpi      String
  providerId       String?
  provider         Provider? @relation(fields: [providerId], references: [id])

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id])

  providerGroupId String?
  providerGroup   ProviderGroup? @relation(fields: [providerGroupId], references: [id])

  esmdTransactionId String?
  hihDeliveryAt     DateTime?
  letterDate        DateTime?
  respondBy         DateTime?
  jurisdiction      String?
  programName       String?
  stage             String?
  language          String?
  bSendAck          Boolean?
  ackUniqueId       String?
  rcOid             String?
  letterName        String?

  raw Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([customerId])
  @@index([providerNpi])
  @@index([letterDate])
}

model PostpayOtherLetter {
  id               String    @id @default(cuid())
  externalLetterId String    @unique
  downloadId       String? // otherPostPayEMDRId
  providerNpi      String
  providerId       String?
  provider         Provider? @relation(fields: [providerId], references: [id])

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id])

  providerGroupId String?
  providerGroup   ProviderGroup? @relation(fields: [providerGroupId], references: [id])

  esmdTransactionId String?
  hihDeliveryAt     DateTime?
  letterDate        DateTime?
  respondBy         DateTime?
  jurisdiction      String?
  programName       String?
  stage             String?
  language          String?
  bSendAck          Boolean?
  ackUniqueId       String?
  rcOid             String?
  letterName        String?

  raw Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([customerId])
  @@index([providerNpi])
  @@index([letterDate])
}

// ============================
// Audit Log
// ============================
model AuditLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // who
  userId    String?
  userEmail String?
  userName  String?
  rolesCsv  String?

  // scope
  customerId String?

  // what
  action     String
  entityType String?
  entityId   String?

  // request context
  route     String?
  ip        String?
  userAgent String?
  requestId String? // NEW
  traceId   String? // NEW
  spanId    String? // NEW

  // result
  success Boolean @default(true)
  message String?

  // integrity / diffs (optional but useful)
  beforeHash String? // NEW
  afterHash  String? // NEW
  prevHash   String? // NEW (for hash-chain)

  // raw payloads (kept small)
  meta    Json?
  payload Json?

  @@index([createdAt])
  @@index([action, createdAt])
  @@index([entityType, entityId])
  @@index([userId, createdAt])
  @@index([customerId, createdAt])
  @@index([requestId, createdAt]) // NEW
}

model AppLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  level     String // debug | info | warn | error
  module    String? // e.g., 'submissions', 'letters', 'auth'
  event     String? // e.g., 'FILE_UPLOAD', 'BUTTON_CLICK', 'ROUTE_HIT'
  message   String?

  // correlation
  requestId String?
  traceId   String?
  spanId    String?

  // http/perf
  method    String?
  route     String?
  status    Int?
  latencyMs Int?
  clientIp  String?
  userAgent String?

  // tenant/user
  customerId String?
  providerId String?
  userId     String?

  // custom structured fields
  data Json?

  @@index([createdAt])
  @@index([level, createdAt])
  @@index([module, event, createdAt])
  @@index([requestId, createdAt])
  @@index([customerId, createdAt])
}

model SecurityEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  kind      String // e.g., LOGIN, LOGOUT, MFA_ENROLL, MFA_VERIFY, ROLE_CHANGE, ACCESS_DENIED, RATE_LIMIT
  message   String?

  // actor & scope
  userId     String?
  userEmail  String?
  customerId String?

  // context
  ip        String?
  userAgent String?
  requestId String?

  // result & reason
  success Boolean @default(true)
  reason  String?

  data Json?

  @@index([createdAt])
  @@index([kind, createdAt])
  @@index([userId, createdAt])
  @@index([customerId, createdAt])
}
